import os
import json
from datetime import datetime
from typing import Dict, Any
from django.conf import settings
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
from docx import Document
from docx.shared import Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
import uuid
from ..models import RepositoryAnalysis, ExportFile


class ExportService:
    """Service for exporting repository analysis to various formats"""
    
    def __init__(self):
        self.export_dir = settings.EXPORT_ROOT
        os.makedirs(self.export_dir, exist_ok=True)
    
    def export_analysis(self, analysis: RepositoryAnalysis, format_type: str) -> ExportFile:
        """
        Export analysis to specified format
        
        Args:
            analysis: RepositoryAnalysis instance
            format_type: Export format ('md', 'txt', 'pdf', 'docx')
            
        Returns:
            ExportFile instance
        """
        # Generate filename
        filename = f"{analysis.repository_name}_{analysis.owner}_{format_type}_{uuid.uuid4().hex[:8]}.{format_type}"
        file_path = os.path.join(self.export_dir, filename)
        
        # Export based on format
        if format_type == 'md':
            self._export_markdown(analysis, file_path)
        elif format_type == 'txt':
            self._export_text(analysis, file_path)
        elif format_type == 'pdf':
            self._export_pdf(analysis, file_path)
        elif format_type == 'docx':
            self._export_docx(analysis, file_path)
        else:
            raise ValueError(f"Unsupported format: {format_type}")
        
        # Get file size
        file_size = os.path.getsize(file_path) if os.path.exists(file_path) else 0
        
        # Create or update export record
        export_file, created = ExportFile.objects.get_or_create(
            analysis=analysis,
            format=format_type,
            defaults={
                'file_path': filename,  # Store relative path
                'file_size': file_size
            }
        )
        
        if not created:
            # Update existing record
            export_file.file_path = filename
            export_file.file_size = file_size
            export_file.save()
        
        return export_file
    
    def _export_markdown(self, analysis: RepositoryAnalysis, file_path: str):
        """Export analysis as Markdown file"""
        content = f"""# {analysis.repository_name} - Repository Analysis

**Repository URL:** {analysis.repository_url}
**Owner:** {analysis.owner}
**Analysis Date:** {analysis.created_at.strftime('%Y-%m-%d %H:%M:%S')}

## Repository Information

- **Name:** {analysis.repository_name}
- **Description:** {analysis.description}
- **Primary Language:** {analysis.language}
- **Stars:** {analysis.stars:,}
- **Forks:** {analysis.forks:,}

## Summary

{analysis.summary}

## Technology Stack

{self._format_tech_stack_markdown(analysis.tech_stack)}

## Setup Instructions

{analysis.setup_instructions}

## File Structure

{self._format_file_structure_markdown(analysis.file_structure)}

## Analysis Details

- **Analysis ID:** {analysis.id}
- **Status:** {analysis.status}
- **Created:** {analysis.created_at.strftime('%Y-%m-%d %H:%M:%S')}
- **Last Updated:** {analysis.updated_at.strftime('%Y-%m-%d %H:%M:%S')}

---
*Generated by Repo Insight Generator*
"""
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
    
    def _export_text(self, analysis: RepositoryAnalysis, file_path: str):
        """Export analysis as plain text file"""
        content = f"""{analysis.repository_name} - Repository Analysis
{'=' * (len(analysis.repository_name) + 22)}

Repository URL: {analysis.repository_url}
Owner: {analysis.owner}
Analysis Date: {analysis.created_at.strftime('%Y-%m-%d %H:%M:%S')}

REPOSITORY INFORMATION
=====================
Name: {analysis.repository_name}
Description: {analysis.description}
Primary Language: {analysis.language}
Stars: {analysis.stars:,}
Forks: {analysis.forks:,}

SUMMARY
=======
{analysis.summary}

TECHNOLOGY STACK
===============
{self._format_tech_stack_text(analysis.tech_stack)}

SETUP INSTRUCTIONS
=================
{analysis.setup_instructions}

FILE STRUCTURE
==============
{self._format_file_structure_text(analysis.file_structure)}

ANALYSIS DETAILS
===============
Analysis ID: {analysis.id}
Status: {analysis.status}
Created: {analysis.created_at.strftime('%Y-%m-%d %H:%M:%S')}
Last Updated: {analysis.updated_at.strftime('%Y-%m-%d %H:%M:%S')}

Generated by Repo Insight Generator
"""
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
    
    def _export_pdf(self, analysis: RepositoryAnalysis, file_path: str):
        """Export analysis as PDF file"""
        doc = SimpleDocTemplate(file_path, pagesize=A4)
        styles = getSampleStyleSheet()
        story = []
        
        # Title
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=18,
            spaceAfter=30,
            textColor=colors.darkblue
        )
        story.append(Paragraph(f"{analysis.repository_name} - Repository Analysis", title_style))
        story.append(Spacer(1, 12))
        
        # Repository information
        repo_data = [
            ["Repository URL", analysis.repository_url],
            ["Owner", analysis.owner],
            ["Description", analysis.description or "N/A"],
            ["Primary Language", analysis.language or "N/A"],
            ["Stars", f"{analysis.stars:,}"],
            ["Forks", f"{analysis.forks:,}"],
            ["Analysis Date", analysis.created_at.strftime('%Y-%m-%d %H:%M:%S')]
        ]
        
        repo_table = Table(repo_data, colWidths=[2*inch, 4*inch])
        repo_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        story.append(repo_table)
        story.append(Spacer(1, 20))
        
        # Summary
        story.append(Paragraph("Summary", styles['Heading2']))
        story.append(Paragraph(analysis.summary, styles['Normal']))
        story.append(Spacer(1, 12))
        
        # Technology Stack
        story.append(Paragraph("Technology Stack", styles['Heading2']))
        tech_stack_text = self._format_tech_stack_text(analysis.tech_stack)
        story.append(Paragraph(tech_stack_text.replace('\n', '<br/>'), styles['Normal']))
        story.append(Spacer(1, 12))
        
        # Setup Instructions
        story.append(Paragraph("Setup Instructions", styles['Heading2']))
        setup_text = analysis.setup_instructions.replace('\n', '<br/>')
        story.append(Paragraph(setup_text, styles['Normal']))
        
        doc.build(story)
    
    def _export_docx(self, analysis: RepositoryAnalysis, file_path: str):
        """Export analysis as Word document"""
        doc = Document()
        
        # Title
        title = doc.add_heading(f"{analysis.repository_name} - Repository Analysis", 0)
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # Repository information table
        doc.add_heading('Repository Information', level=1)
        table = doc.add_table(rows=7, cols=2)
        table.style = 'Light Grid Accent 1'
        
        repo_info = [
            ("Repository URL", analysis.repository_url),
            ("Owner", analysis.owner),
            ("Description", analysis.description or "N/A"),
            ("Primary Language", analysis.language or "N/A"),
            ("Stars", f"{analysis.stars:,}"),
            ("Forks", f"{analysis.forks:,}"),
            ("Analysis Date", analysis.created_at.strftime('%Y-%m-%d %H:%M:%S'))
        ]
        
        for i, (key, value) in enumerate(repo_info):
            row_cells = table.rows[i].cells
            row_cells[0].text = key
            row_cells[1].text = str(value)
        
        # Summary
        doc.add_heading('Summary', level=1)
        doc.add_paragraph(analysis.summary)
        
        # Technology Stack
        doc.add_heading('Technology Stack', level=1)
        tech_stack_text = self._format_tech_stack_text(analysis.tech_stack)
        doc.add_paragraph(tech_stack_text)
        
        # Setup Instructions
        doc.add_heading('Setup Instructions', level=1)
        doc.add_paragraph(analysis.setup_instructions)
        
        # File Structure
        doc.add_heading('File Structure', level=1)
        file_structure_text = self._format_file_structure_text(analysis.file_structure)
        doc.add_paragraph(file_structure_text)
        
        # Analysis Details
        doc.add_heading('Analysis Details', level=1)
        details_table = doc.add_table(rows=4, cols=2)
        details_table.style = 'Light Grid Accent 1'
        
        details_info = [
            ("Analysis ID", str(analysis.id)),
            ("Status", analysis.status.title()),
            ("Created", analysis.created_at.strftime('%Y-%m-%d %H:%M:%S')),
            ("Last Updated", analysis.updated_at.strftime('%Y-%m-%d %H:%M:%S'))
        ]
        
        for i, (key, value) in enumerate(details_info):
            row_cells = details_table.rows[i].cells
            row_cells[0].text = key
            row_cells[1].text = value
        
        # Footer
        footer_paragraph = doc.add_paragraph()
        footer_paragraph.add_run('\nGenerated by Repo Insight Generator').italic = True
        
        doc.save(file_path)
    
    def _format_tech_stack_markdown(self, tech_stack: Dict) -> str:
        """Format technology stack for Markdown"""
        if not tech_stack:
            return "No technology stack information available."
        
        formatted = []
        
        for category, technologies in tech_stack.items():
            if technologies and isinstance(technologies, list):
                category_name = category.replace('_', ' ').title()
                tech_list = ', '.join(technologies)
                formatted.append(f"**{category_name}:** {tech_list}")
        
        return '\n'.join(formatted) if formatted else "No technology stack information available."
    
    def _format_tech_stack_text(self, tech_stack: Dict) -> str:
        """Format technology stack for plain text"""
        if not tech_stack:
            return "No technology stack information available."
        
        formatted = []
        
        for category, technologies in tech_stack.items():
            if technologies and isinstance(technologies, list):
                category_name = category.replace('_', ' ').title()
                tech_list = ', '.join(technologies)
                formatted.append(f"{category_name}: {tech_list}")
        
        return '\n'.join(formatted) if formatted else "No technology stack information available."
    
    def _format_file_structure_markdown(self, file_structure: Dict) -> str:
        """Format file structure for Markdown"""
        if not file_structure:
            return "No file structure information available."
        
        formatted = []
        
        # Languages
        languages = file_structure.get('languages', {})
        if languages:
            formatted.append("### Languages")
            for lang, bytes_count in languages.items():
                formatted.append(f"- **{lang}:** {bytes_count:,} bytes")
            formatted.append("")
        
        # File analysis
        analysis = file_structure.get('analysis', {})
        if analysis:
            for category, files in analysis.items():
                if files and isinstance(files, list):
                    category_name = category.replace('_', ' ').title()
                    formatted.append(f"### {category_name}")
                    for file_name in files[:10]:  # Limit to first 10 files
                        formatted.append(f"- {file_name}")
                    if len(files) > 10:
                        formatted.append(f"- ... and {len(files) - 10} more")
                    formatted.append("")
        
        return '\n'.join(formatted) if formatted else "No file structure information available."
    
    def _format_file_structure_text(self, file_structure: Dict) -> str:
        """Format file structure for plain text"""
        if not file_structure:
            return "No file structure information available."
        
        formatted = []
        
        # Total files
        total_files = file_structure.get('total_files', 0)
        if total_files:
            formatted.append(f"Total Files: {total_files}")
            formatted.append("")
        
        # Languages
        languages = file_structure.get('languages', {})
        if languages:
            formatted.append("Languages:")
            for lang, bytes_count in languages.items():
                formatted.append(f"  {lang}: {bytes_count:,} bytes")
            formatted.append("")
        
        # File analysis
        analysis = file_structure.get('analysis', {})
        if analysis:
            for category, files in analysis.items():
                if files and isinstance(files, list):
                    category_name = category.replace('_', ' ').title()
                    formatted.append(f"{category_name}:")
                    for file_name in files[:10]:  # Limit to first 10 files
                        formatted.append(f"  - {file_name}")
                    if len(files) > 10:
                        formatted.append(f"  - ... and {len(files) - 10} more")
                    formatted.append("")
        
        return '\n'.join(formatted) if formatted else "No file structure information available."
    
    def get_export_file_path(self, export_file: ExportFile) -> str:
        """Get full file path for an export file"""
        return os.path.join(self.export_dir, export_file.file_path)
    
    def delete_export_file(self, export_file: ExportFile):
        """Delete an export file from filesystem"""
        file_path = self.get_export_file_path(export_file)
        if os.path.exists(file_path):
            os.remove(file_path)