"""
Export Service for Repository Analysis Reports

This service handles the generation of analysis reports in multiple formats:
- Markdown (.md)
- Plain Text (.txt)
- PDF (.pdf)
- Word Document (.docx)
"""

import io
import os
from typing import Dict, Any, Optional
from datetime import datetime
import logging

# PDF generation
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors

# Word document generation
from docx import Document
from docx.shared import Inches
from docx.enum.style import WD_STYLE_TYPE

logger = logging.getLogger(__name__)


class ExportService:
    """Service for exporting repository analysis to various formats."""
    
    def __init__(self):
        self.styles = getSampleStyleSheet()
        
    def generate_markdown(self, analysis_data: Dict[str, Any]) -> str:
        """
        Generate Markdown format report.
        
        Args:
            analysis_data: Repository analysis data
            
        Returns:
            Markdown formatted string
        """
        md_content = []
        
        # Header
        repo_name = f"{analysis_data.get('owner', 'Unknown')}/{analysis_data.get('repo', 'Unknown')}"
        md_content.append(f"# Repository Analysis: {repo_name}")
        md_content.append(f"**Generated on:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        md_content.append(f"**Repository URL:** {analysis_data.get('url', 'N/A')}")
        md_content.append("")
        
        # Repository Information
        if analysis_data.get('info'):
            info = analysis_data['info']
            md_content.append("## Repository Information")
            md_content.append(f"- **Description:** {info.get('description', 'No description available')}")
            md_content.append(f"- **Stars:** {info.get('stargazers_count', 0)}")
            md_content.append(f"- **Forks:** {info.get('forks_count', 0)}")
            md_content.append(f"- **Language:** {info.get('language', 'Not specified')}")
            md_content.append(f"- **Created:** {info.get('created_at', 'Unknown')}")
            md_content.append(f"- **Last Updated:** {info.get('updated_at', 'Unknown')}")
            md_content.append("")
        
        # Languages
        if analysis_data.get('languages'):
            md_content.append("## Programming Languages")
            total_bytes = sum(analysis_data['languages'].values())
            for lang, bytes_count in sorted(analysis_data['languages'].items(), key=lambda x: x[1], reverse=True):
                percentage = (bytes_count / total_bytes) * 100 if total_bytes > 0 else 0
                md_content.append(f"- **{lang}:** {percentage:.1f}% ({bytes_count:,} bytes)")
            md_content.append("")
        
        # Important Files
        if analysis_data.get('important_files'):
            md_content.append("## Important Files Found")
            for file_path in sorted(analysis_data['important_files'].keys()):
                md_content.append(f"- `{file_path}`")
            md_content.append("")
        
        # AI Analysis Results
        if analysis_data.get('analysis'):
            ai_analysis = analysis_data['analysis']
            
            if ai_analysis.get('summary'):
                md_content.append("## Repository Summary")
                md_content.append(ai_analysis['summary'])
                md_content.append("")
            
            if ai_analysis.get('tech_stack'):
                md_content.append("## Technology Stack")
                md_content.append(ai_analysis['tech_stack'])
                md_content.append("")
            
            if ai_analysis.get('setup_instructions'):
                md_content.append("## Setup Instructions")
                md_content.append(ai_analysis['setup_instructions'])
                md_content.append("")
        
        # Recent Activity
        if analysis_data.get('recent_commits'):
            md_content.append("## Recent Commits")
            for commit in analysis_data['recent_commits'][:5]:  # Show only last 5
                commit_info = commit.get('commit', {})
                author = commit_info.get('author', {})
                md_content.append(f"- **{commit_info.get('message', 'No message')[:60]}...** by {author.get('name', 'Unknown')} on {author.get('date', 'Unknown')}")
            md_content.append("")
        
        # Footer
        md_content.append("---")
        md_content.append("*Report generated by Repo Insight Generator*")
        
        return "\n".join(md_content)
    
    def generate_text(self, analysis_data: Dict[str, Any]) -> str:
        """
        Generate plain text format report.
        
        Args:
            analysis_data: Repository analysis data
            
        Returns:
            Plain text formatted string
        """
        # Convert markdown to plain text by removing markdown syntax
        md_content = self.generate_markdown(analysis_data)
        
        # Remove markdown formatting
        text_content = md_content
        text_content = text_content.replace("# ", "")
        text_content = text_content.replace("## ", "")
        text_content = text_content.replace("### ", "")
        text_content = text_content.replace("**", "")
        text_content = text_content.replace("*", "")
        text_content = text_content.replace("`", "")
        text_content = text_content.replace("- ", "  â€¢ ")
        
        return text_content
    
    def generate_pdf(self, analysis_data: Dict[str, Any]) -> bytes:
        """
        Generate PDF format report.
        
        Args:
            analysis_data: Repository analysis data
            
        Returns:
            PDF content as bytes
        """
        buffer = io.BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=A4, topMargin=1*inch)
        
        # Build story (content elements)
        story = []
        
        # Title
        repo_name = f"{analysis_data.get('owner', 'Unknown')}/{analysis_data.get('repo', 'Unknown')}"
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=self.styles['Heading1'],
            fontSize=20,
            spaceAfter=30,
            textColor=colors.darkblue
        )
        story.append(Paragraph(f"Repository Analysis: {repo_name}", title_style))
        
        # Metadata
        meta_data = [
            ["Generated on:", datetime.now().strftime('%Y-%m-%d %H:%M:%S')],
            ["Repository URL:", analysis_data.get('url', 'N/A')]
        ]
        meta_table = Table(meta_data, colWidths=[2*inch, 4*inch])
        meta_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
        ]))
        story.append(meta_table)
        story.append(Spacer(1, 0.2*inch))
        
        # Repository Information
        if analysis_data.get('info'):
            info = analysis_data['info']
            story.append(Paragraph("Repository Information", self.styles['Heading2']))
            
            repo_data = [
                ["Description:", info.get('description', 'No description available')],
                ["Stars:", str(info.get('stargazers_count', 0))],
                ["Forks:", str(info.get('forks_count', 0))],
                ["Primary Language:", info.get('language', 'Not specified')],
                ["Created:", info.get('created_at', 'Unknown')],
                ["Last Updated:", info.get('updated_at', 'Unknown')]
            ]
            
            repo_table = Table(repo_data, colWidths=[1.5*inch, 4.5*inch])
            repo_table.setStyle(TableStyle([
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ]))
            story.append(repo_table)
            story.append(Spacer(1, 0.2*inch))
        
        # Programming Languages
        if analysis_data.get('languages'):
            story.append(Paragraph("Programming Languages", self.styles['Heading2']))
            total_bytes = sum(analysis_data['languages'].values())
            
            lang_data = [["Language", "Percentage", "Bytes"]]
            for lang, bytes_count in sorted(analysis_data['languages'].items(), key=lambda x: x[1], reverse=True):
                percentage = (bytes_count / total_bytes) * 100 if total_bytes > 0 else 0
                lang_data.append([lang, f"{percentage:.1f}%", f"{bytes_count:,}"])
            
            lang_table = Table(lang_data)
            lang_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ]))
            story.append(lang_table)
            story.append(Spacer(1, 0.2*inch))
        
        # AI Analysis sections
        if analysis_data.get('analysis'):
            ai_analysis = analysis_data['analysis']
            
            for section_name, section_key in [
                ("Repository Summary", "summary"),
                ("Technology Stack", "tech_stack"),
                ("Setup Instructions", "setup_instructions")
            ]:
                if ai_analysis.get(section_key):
                    story.append(Paragraph(section_name, self.styles['Heading2']))
                    story.append(Paragraph(ai_analysis[section_key], self.styles['Normal']))
                    story.append(Spacer(1, 0.15*inch))
        
        # Build PDF
        doc.build(story)
        pdf_content = buffer.getvalue()
        buffer.close()
        
        return pdf_content
    
    def generate_docx(self, analysis_data: Dict[str, Any]) -> bytes:
        """
        Generate Word document format report.
        
        Args:
            analysis_data: Repository analysis data
            
        Returns:
            DOCX content as bytes
        """
        doc = Document()
        
        # Title
        repo_name = f"{analysis_data.get('owner', 'Unknown')}/{analysis_data.get('repo', 'Unknown')}"
        title = doc.add_heading(f"Repository Analysis: {repo_name}", 0)
        
        # Metadata
        doc.add_paragraph(f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        doc.add_paragraph(f"Repository URL: {analysis_data.get('url', 'N/A')}")
        doc.add_paragraph()
        
        # Repository Information
        if analysis_data.get('info'):
            info = analysis_data['info']
            doc.add_heading('Repository Information', level=1)
            
            table = doc.add_table(rows=6, cols=2)
            table.style = 'Table Grid'
            
            table.cell(0, 0).text = 'Description'
            table.cell(0, 1).text = info.get('description', 'No description available')
            
            table.cell(1, 0).text = 'Stars'
            table.cell(1, 1).text = str(info.get('stargazers_count', 0))
            
            table.cell(2, 0).text = 'Forks'
            table.cell(2, 1).text = str(info.get('forks_count', 0))
            
            table.cell(3, 0).text = 'Primary Language'
            table.cell(3, 1).text = info.get('language', 'Not specified')
            
            table.cell(4, 0).text = 'Created'
            table.cell(4, 1).text = info.get('created_at', 'Unknown')
            
            table.cell(5, 0).text = 'Last Updated'
            table.cell(5, 1).text = info.get('updated_at', 'Unknown')
            
            doc.add_paragraph()
        
        # Programming Languages
        if analysis_data.get('languages'):
            doc.add_heading('Programming Languages', level=1)
            total_bytes = sum(analysis_data['languages'].values())
            
            for lang, bytes_count in sorted(analysis_data['languages'].items(), key=lambda x: x[1], reverse=True):
                percentage = (bytes_count / total_bytes) * 100 if total_bytes > 0 else 0
                doc.add_paragraph(f"{lang}: {percentage:.1f}% ({bytes_count:,} bytes)", style='List Bullet')
            
            doc.add_paragraph()
        
        # Important Files
        if analysis_data.get('important_files'):
            doc.add_heading('Important Files Found', level=1)
            for file_path in sorted(analysis_data['important_files'].keys()):
                doc.add_paragraph(file_path, style='List Bullet')
            doc.add_paragraph()
        
        # AI Analysis sections
        if analysis_data.get('analysis'):
            ai_analysis = analysis_data['analysis']
            
            for section_name, section_key in [
                ("Repository Summary", "summary"),
                ("Technology Stack", "tech_stack"),
                ("Setup Instructions", "setup_instructions")
            ]:
                if ai_analysis.get(section_key):
                    doc.add_heading(section_name, level=1)
                    doc.add_paragraph(ai_analysis[section_key])
                    doc.add_paragraph()
        
        # Recent Activity
        if analysis_data.get('recent_commits'):
            doc.add_heading('Recent Commits', level=1)
            for commit in analysis_data['recent_commits'][:5]:
                commit_info = commit.get('commit', {})
                author = commit_info.get('author', {})
                message = commit_info.get('message', 'No message')[:60] + "..."
                doc.add_paragraph(f"{message} by {author.get('name', 'Unknown')} on {author.get('date', 'Unknown')}", style='List Bullet')
        
        # Save to bytes
        buffer = io.BytesIO()
        doc.save(buffer)
        docx_content = buffer.getvalue()
        buffer.close()
        
        return docx_content
    
    def export_analysis(self, analysis_data: Dict[str, Any], format_type: str) -> Optional[bytes]:
        """
        Export analysis data in the specified format.
        
        Args:
            analysis_data: Repository analysis data
            format_type: Export format ('md', 'txt', 'pdf', 'docx')
            
        Returns:
            Export content as bytes or None if error
        """
        try:
            if format_type.lower() == 'md':
                content = self.generate_markdown(analysis_data)
                return content.encode('utf-8')
            
            elif format_type.lower() == 'txt':
                content = self.generate_text(analysis_data)
                return content.encode('utf-8')
            
            elif format_type.lower() == 'pdf':
                return self.generate_pdf(analysis_data)
            
            elif format_type.lower() == 'docx':
                return self.generate_docx(analysis_data)
            
            else:
                logger.error(f"Unsupported export format: {format_type}")
                return None
                
        except Exception as e:
            logger.error(f"Error exporting analysis as {format_type}: {str(e)}")
            return None
    
    def get_filename(self, analysis_data: Dict[str, Any], format_type: str) -> str:
        """
        Generate appropriate filename for exported analysis.
        
        Args:
            analysis_data: Repository analysis data
            format_type: Export format
            
        Returns:
            Suggested filename
        """
        repo_name = f"{analysis_data.get('owner', 'unknown')}_{analysis_data.get('repo', 'repository')}"
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        # Sanitize filename
        safe_repo_name = "".join(c for c in repo_name if c.isalnum() or c in "._-")
        
        return f"repo_analysis_{safe_repo_name}_{timestamp}.{format_type.lower()}"


# Example usage
if __name__ == "__main__":
    # Example analysis data
    sample_data = {
        'owner': 'octocat',
        'repo': 'Hello-World',
        'url': 'https://github.com/octocat/Hello-World',
        'info': {
            'description': 'My first repository on GitHub!',
            'stargazers_count': 1500,
            'forks_count': 800,
            'language': 'Python',
            'created_at': '2011-01-26T19:01:12Z',
            'updated_at': '2023-12-01T10:30:45Z'
        },
        'languages': {
            'Python': 15000,
            'JavaScript': 8000,
            'HTML': 3000
        },
        'important_files': {
            'README.md': 'Repository readme content...',
            'requirements.txt': 'flask==2.0.1\nrequests==2.25.1'
        },
        'analysis': {
            'summary': 'This is a sample Python web application using Flask framework.',
            'tech_stack': 'Python, Flask, JavaScript, HTML',
            'setup_instructions': '1. Clone the repository\n2. Install dependencies\n3. Run the application'
        }
    }
    
    export_service = ExportService()
    
    # Test different formats
    for format_type in ['md', 'txt', 'pdf', 'docx']:
        content = export_service.export_analysis(sample_data, format_type)
        if content:
            filename = export_service.get_filename(sample_data, format_type)
            print(f"Generated {format_type.upper()} export: {filename} ({len(content)} bytes)")
        else:
            print(f"Failed to generate {format_type.upper()} export")